# =============================================================================
# DGHI Madagascar - End-to-End Climate & Disease Pipeline (Arrow + base R)
# Rebuilds everything: ingest ??? mapping ??? hourly/daily ??? disease/workability ???
# clean deliverables ??? seasonal timing ??? risk-days (day-level).
# =============================================================================

suppressPackageStartupMessages({
  library(arrow)
  library(dplyr)
  library(data.table)
  library(lubridate)
  library(here)
})


# ---- Load helper functions ----
source(here("helpers", "helpers.R"))

# ---- Configurable paths via .Renviron ----
# In your ~/.Renviron or project .Renviron file, set:
#   ERA5_MADAGASCAR=C:/Users/jordan/Google Drive/CHI-Data/era5_madagascar
#   ERA5_STREAM=C:/Users/jordan/Google Drive/CHI-Data/madagascar_streamed
#
# To check what R sees:
# Sys.getenv("ERA5_MADAGASCAR")

era5_root <- Sys.getenv("ERA5_MADAGASCAR", unset = NA)
if (is.na(era5_root)) {
  stop("Environment variable ERA5_MADAGASCAR not set. Please edit your .Renviron.")
  # usethis::edit_r_environ("project")
  # Sys.setenv("ERA5_MADAGASCAR" = "G:/My Drive/Duke/DGHI/data/")
}

out_root <- file.path(era5_root, "madagascar_outputs")
dir.create(out_root, recursive = TRUE, showWarnings = FALSE)

stream_dir <- Sys.getenv("ERA5_STREAM", unset = file.path(out_root, "streamed"))
dir.create(stream_dir, recursive = TRUE, showWarnings = FALSE)




# ---- Analysis settings ----
years_all   <- 1980:2024
tz_local      <- "Indian/Antananarivo"
tz_offset_sec <- 3L * 3600L



villages <- data.table(
  village = c("Sarahandrano","Mandena"),
  lon     = c(49.6493707, 49.8117457),
  lat     = c(-14.6073478, -14.4774428),
  elev_m  = c(1347, 1348)
)






# # In code, users set a local environment variable in .Renviron like:
# #   ERA5_MADAGASCAR=C:/Users/you/Google Drive/CHI-Data/era5_madagascar
# # and then load it with:
# # era5_root <- Sys.getenv("ERA5_MADAGASCAR")
# 
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# # 0) CONFIG
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# # Root ERA5 data folder (year-subdirs with parquet inside)
# era5_root   <- "E:/data/gridded/era5-africa/processed"   # <- change if needed
# out_root    <- file.path(era5_root, "madagascar_outputs") # all outputs here
# dir.create(out_root, recursive = TRUE, showWarnings = FALSE)
# 
# # Analysis years
# years_all   <- 1980:2024
# # years_clean <- 2000:2022      # use this for "clean" deliverables
# 
# # Timezone: Madagascar
# tz_local      <- "Indian/Antananarivo"
# tz_offset_sec <- 3L * 3600L
# 
# # Villages (Mandena & Sarahandrano anchors you provided)
# villages <- data.table(
#   village = c("Sarahandrano","Mandena"),
#   lon = c(49.6493707, 49.8117457),
#   lat = c(-14.6073478, -14.4774428),
#   elev_m = c(1347, 1348)
# )
# 
# # Streaming output (small, village-weighted)
# stream_dir <-"C:/data/gridded/era5land/madagascar/madagascar_hourly_daily_streamed" #  file.path(out_root, "streamed")
# dir.create(stream_dir, recursive = TRUE, showWarnings = FALSE)
# 
# 
# 





# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 1) VARIABLE MAP (EDIT HERE IF YOUR COLUMN NAMES DIFFER)
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# ERA5 parquet per-hour columns expected in each year folder:
#  - validTime: integer seconds since epoch (UTC) or timestamp
#  - ssrd:      surface solar radiation downwards (J m^-2 per hour)
#  - ta_scaled10_degC:  air temp *10 (°C * 10)
#  - td_scaled10_degC:  dewpoint *10 (°C * 10)
#  - wbgt_scaled10_degC: WBGT *10 (°C * 10)   (if absent, set wbgt = NA)
#  - wind2m_scaled10_ms1: wind at 2m *10 (m s^-1 *10)  (optional)
#  - lat_idx_x4 / lon_idx_x4: 0.25° grid-center indices (lat=idx/4, lon=idx/4)
VAR_VALIDTIME <- "validTime"
VAR_SSRD      <- "ssrd"
VAR_TA10      <- "ta_scaled10_degC"
VAR_TD10      <- "td_scaled10_degC"
VAR_WBGT10    <- "wbgt_scaled10_degC"
VAR_WIND10    <- "wind2m_scaled10_ms1"


VAR_LATIDX    <- "lat_idx_x4"
VAR_LONIDX    <- "lon_idx_x4"

# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 2) HELPERS
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
scale10 <- function(x) as.numeric(x) / 10

# Workability S-curve: % workable per hour from WBGT
workability <- function(wbgt, steepness = 0.6, midpoint = 30) {
  100 * (1 - 1 / (1 + exp(-steepness * (wbgt - midpoint))))
}

# Build village???grid weights using 3×3 **centers** (not corners)
to_idx <- function(x) round(x * 4)
dist2_m2 <- function(lon1, lat1, lon2, lat2) {
  r <- 6371000
  x <- (lon2 - lon1) * cos((lat1 + lat2) * pi / 360)
  y <- (lat2 - lat1)
  (r * pi / 180)^2 * (x^2 + y^2)
}

to_idx <- function(x) round(x * 4)

make_weights_centers <- function(villages_dt, K_idw = 4L) {
  stopifnot(all(c("village","lon","lat") %in% names(villages_dt)))
  out <- vector("list", nrow(villages_dt))
  
  for (i in seq_len(nrow(villages_dt))) {
    v <- villages_dt[i]
    
    i_lat <- to_idx(v$lat)
    i_lon <- to_idx(v$lon)
    
    # 3x3 candidate **centers**
    cand <- CJ(
      lat_idx_x4 = as.integer((i_lat - 1):(i_lat + 1)),
      lon_idx_x4 = as.integer((i_lon - 1):(i_lon + 1))
    )
    
    # two-step creation so we can reference lat_c/lon_c when computing d2
    cand[, `:=`(
      lat_c = lat_idx_x4 / 4,
      lon_c = lon_idx_x4 / 4
    )]
    cand[, d2 := dist2_m2(v$lon, v$lat, lon_c, lat_c)]
    
    # K = 1 nearest center
    k1 <- cand[which.min(d2), .(lat_idx_x4, lon_idx_x4)]
    k1[, `:=`(scheme = "nearest1", village = v$village, weight = 1)]
    
    # K = 4 IDW on nearest centers
    k4 <- cand[order(d2)][1L:K_idw, .(lat_idx_x4, lon_idx_x4, d2)]
    k4[, w := 1 / pmax(d2, 1)]
    k4[, weight := as.numeric(w / sum(w))]
    k4[, `:=`(scheme = "idw4", village = v$village)]
    k4 <- k4[, .(lat_idx_x4, lon_idx_x4, scheme, village, weight)]
    
    out[[i]] <- rbind(
      k1[, .(lat_idx_x4, lon_idx_x4, scheme, village, weight)],
      k4
    )
  }
  
  ans <- rbindlist(out)
  setcolorder(ans, c("scheme","village","lat_idx_x4","lon_idx_x4","weight"))
  ans[]
}



list.files(stream_dir, recursive=TRUE)
library(dplyr)

# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 3) INGEST: READ ONE YEAR (HOURLY GRID CELLS), RETURN RAW DT
#    (Lazy Arrow read; collect at the end)
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
read_one_year_raw <- function(yr) {
  ydir <- file.path(era5_root, yr)
  if (!dir.exists(ydir)) return(data.table())
  ds <- open_dataset(ydir, format = "parquet",
                     factory_options = list(exclude_invalid_files = TRUE))
  
  if (!"wind2m_scaled10_ms1" %in% names(ds)){
    VAR_WIND10 = 'wind2m_scaled10_ms'
  } else {
    VAR_WIND10 = 'wind2m_scaled10_ms1'
  }
  # names(ds)
  # names(ds)
  # validTime ??? timestamp UTC ??? local date/hour
  # compute derived variables lazily; collect at end
  dt <- ds |>
    select(all_of(c(VAR_LATIDX, VAR_LONIDX, VAR_VALIDTIME,
                    VAR_SSRD, VAR_TA10, VAR_TD10, VAR_WBGT10, VAR_WIND10))) |>
    mutate(
      validTime = cast(cast(!!sym(VAR_VALIDTIME), int64()),
                       timestamp("s", timezone = "UTC")),
      local_ts  = cast(cast(validTime, int64()) + tz_offset_sec, timestamp("s")),
      date      = cast(local_ts, date32()),
      hour      = hour(local_ts),
      
      ta   = round(cast(!!sym(VAR_TA10),    float64()) / 10, 1),
      td   = round(cast(!!sym(VAR_TD10),    float64()) / 10, 1),
      wbgt = round(cast(!!sym(VAR_WBGT10),  float64()) / 10, 1),
      wind = round(cast(!!sym(VAR_WIND10),  float64()) / 10, 1),
      
      rh   = exp((17.62 * td) / (243.12 + td) - (17.62 * ta) / (243.12 + ta)) * 100,
      es   = 0.6108 * exp(17.27 * ta / (ta + 237.3)),
      ea   = 0.6108 * exp(17.27 * td / (td + 237.3)),
      vpd  = if_else(es - ea > 0, es - ea, 0.0),
      
      ssrd_MJ = cast(!!sym(VAR_SSRD), float64()) / 1e6
    ) |>
    select(all_of(c(VAR_LATIDX, VAR_LONIDX)), date, hour, ta, td, wbgt, wind, rh, vpd, ssrd_MJ) |>
    collect()
  
  setDT(dt)
  # enforce integer indices
  setnames(dt, c(VAR_LATIDX, VAR_LONIDX), c("lat_idx_x4","lon_idx_x4"))
  dt[, `:=`(lat_idx_x4 = as.integer(lat_idx_x4),
            lon_idx_x4 = as.integer(lon_idx_x4))]
  dt[]
}

# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 4) STREAM PROCESS: HOURLY ??? VILLAGE-WEIGHTED HOURLY + DAILY
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# yr = 2015

process_year <- function(yr, weights_dt) {
  raw <- read_one_year_raw(yr)
  if (nrow(raw) == 0) return(invisible(NULL))
  
  # merge weights (both schemes), compute weighted averages per village/hour
  setDT(raw)
  raw <- merge(raw, weights_dt,
               by = c("lat_idx_x4","lon_idx_x4"), allow.cartesian = TRUE)
  
  # Weighted hourly (per scheme, village, date, hour)
  hr <- raw[, .(
    ta      = sum(ta      * weight, na.rm = TRUE) / sum(weight),
    td      = sum(td      * weight, na.rm = TRUE) / sum(weight),
    wbgt    = sum(wbgt    * weight, na.rm = TRUE) / sum(weight),
    wind    = sum(wind    * weight, na.rm = TRUE) / sum(weight),
    rh      = sum(rh      * weight, na.rm = TRUE) / sum(weight),
    vpd     = sum(vpd     * weight, na.rm = TRUE) / sum(weight),
    ssrd_MJ = sum(ssrd_MJ * weight, na.rm = TRUE) / sum(weight)
  ), by = .(scheme, village, date, hour)]
  
  # Daily aggregates (sums/means)
  dly <- hr[, .(
    tmean_c     = mean(ta, na.rm = TRUE),
    tmax_c      = max(ta,  na.rm = TRUE),
    tmin_c      = min(ta,  na.rm = TRUE),
    dtr_c       = max(ta, na.rm = TRUE) - min(ta, na.rm = TRUE),
    rh_mean     = mean(rh, na.rm = TRUE),
    vpd_kpa     = mean(vpd, na.rm = TRUE),
    ssrd_MJ_day = sum(ssrd_MJ, na.rm = TRUE),       # sum of hourly ??? daily MJ m^-2
    wbgt28_h    = sum(wbgt >= 28, na.rm = TRUE),
    wbgt31_h    = sum(wbgt >= 31, na.rm = TRUE),
    hot35_h     = sum(ta   >= 35, na.rm = TRUE),
    
    # Workability windows
    work_day_pct   = mean(workability(wbgt)[hour %in% 9:16],  na.rm = TRUE),
    work_night_pct = mean(workability(wbgt)[hour %in% c(22:23,0:6)], na.rm = TRUE),
    work_all_pct   = mean(workability(wbgt), na.rm = TRUE)
  ), by = .(scheme, village, date)]
  
  # Disease "risk hours" per day using hours logic (tweak as needed)
  disease_hourly <- function(ta, vpd, rh) {
    # Example: Phytophthora (palm): 20-30 C & (vpd <= 0.7 or rh >= 95)
    list(
      palm = as.integer(ta >= 20 & ta <= 30 & (vpd <= 0.7 | rh >= 95)),
      anth = as.integer(ta >= 22 & ta <= 32 & (vpd <= 0.9 | rh >= 93))
    )
  }
  dh <- hr[, {
    flags <- disease_hourly(ta, vpd, rh)
    .(palm_hours = sum(flags$palm, na.rm = TRUE),
      anth_hours = sum(flags$anth, na.rm = TRUE))
  }, by = .(scheme, village, date)]
  
  dly <- merge(dly, dh, by = c("scheme","village","date"), all.x = TRUE)
  
  # Write parquet partitions (append mode)
  hourly_dir <- file.path(stream_dir, "hourly_agg")
  daily_dir  <- file.path(stream_dir, "daily_agg")
  
  
  dly[, year := year(date)]
  hr[, year := year(date)]
  
  
  dly = dly[year == yr]
  hr = hr[year == yr]
  
  
  # write_parquet()
  write_dataset((hr), path = hourly_dir,
                format = "parquet", partitioning = c("scheme", "village", "year"))
  write_dataset((dly), path = daily_dir,
                format = "parquet", partitioning = c("scheme", "village", "year"))
  invisible(NULL)

  
}

# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# 5) RUN: mapping + per-year streaming
# ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
weights_dt <- make_weights_centers(villages)
# sanity check: villages should have different nearest1 cells
# print(weights_dt[scheme=="nearest1"])
# 

# 9 minutes sequential.
jj::timed('start')
for (yr in years_all) {
  message("Processing year: ", yr)
  try(process_year(yr, weights_dt), silent = TRUE)
}
jj::timed('end')



# years_all = 2003:2005
# 
# 
# library(jj)
# library(foreach)
# library(doParallel)
# env_info <- startEnvironment(num_cores = 3, threshold = 0.99, consecutive_seconds = 20)
# 
# 
# timed('start')
# foreach(ayr = 1:length(years_all),
#         .packages = c('data.table', 'jj', 'arrow', 'dplyr')) %dopar% {
#           
#           
#           # for (afile in 1:nrow(all_grib_allvars_files)){
#           
#           
#           yr <- years_all[ayr]
#           
#           try(process_year(yr, weights_dt), silent = FALSE)
# 
#         }
# 
# 
# 
# timed("end")
# 
# closeEnvironment(env_info)
# 
# 
# 






# 
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# # 6) CLEAN DELIVERABLES (2000-2022): yearly metrics + basic plots
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# daily_ds <- open_dataset(file.path(stream_dir, "daily_agg"), format = "parquet")
# 
# daily_all <- daily_ds |>
#   mutate(year = year(date)) |>
#   filter(year >= 1980, year <= 2022) |>
#   select(scheme, village, date, year,
#          tmean_c, tmax_c, tmin_c, dtr_c, rh_mean, vpd_kpa,
#          ssrd_MJ_day, 
#          wbgt28_h,
#          wbgt31_h,
#          hot35_h,
#          work_day_pct, work_night_pct, work_all_pct,
#          palm_hours, anth_hours) |>
#   collect() |>
#   as.data.table()
# 
# range(daily_all$date)
# 
# daily_all = daily_all[jj::lyear(date) >= 2000]
# 
# daily_all# Yearly totals/means
# yearly <- daily_all[, .(
#   tmean_c   = mean(tmean_c,   na.rm = TRUE),
#   rh_mean   = mean(rh_mean,   na.rm = TRUE),
#   vpd_kpa   = mean(vpd_kpa,   na.rm = TRUE),
#   # wbgt28_y  = sum(wbgt28_h,   na.rm = TRUE),
#   # wbgt31_y  = sum(wbgt31_h,   na.rm = TRUE),
#   # hot35_y   = sum(hot35_h,    na.rm = TRUE),
#   palm_hours_y = sum(palm_hours, na.rm = TRUE),
#   anth_hours_y = sum(anth_hours, na.rm = TRUE),
#   work_day_pct = mean(work_day_pct, na.rm = TRUE),
#   work_all_pct = mean(work_all_pct, na.rm = TRUE)
# ), by = .(scheme, village, year)]
# 
# # Save clean yearly/daily for reference
# clean_dir <- file.path(out_root, "clean_2000_2022")
# dir.create(clean_dir, showWarnings = FALSE, recursive = TRUE)
# write_dataset(as_arrow_table(yearly), path = file.path(clean_dir, "yearly"),
#               format = "parquet", partitioning = c("scheme","village"))
# write_dataset(as_arrow_table(daily_all), path = file.path(clean_dir, "daily"),
#               format = "parquet", partitioning = c("scheme","village"))
# 
# # Base R plot: Phytophthora hours per year (nearest1)
# yr_near <- yearly[scheme == "nearest1"]
# png(file.path(clean_dir, "P1_palm_hours_year_lines_nearest1.png"), 1400, 900, res = 150)
# par(mar=c(4.2,5,3,1.2), mgp=c(2.6,0.9,0), las=1, tcl=-0.25, cex.main=1.5, cex.lab=1.3, cex.axis=1.1)
# cols <- c("Mandena"="gray20","Sarahandrano"="gray55")
# yl <- range(pretty(yr_near$palm_hours_y, 8), na.rm = TRUE)
# plot(NA, xlim = range(yr_near$year), ylim = yl, xaxs="i",
#      xlab = "Year", ylab = "Phytophthora-favorable hours / year",
#      main = "Phytophthora-favorable hours (nearest1)")
# abline(h = pretty(yl), col = "gray90")
# for (vil in names(cols)) {
#   s <- yr_near[village == vil][order(year)]
#   lines(s$year, s$palm_hours_y, lwd = 2, col = cols[vil])
#   points(s$year, s$palm_hours_y, pch = 16, col = cols[vil])
# }
# legend("topleft", bty="n", lwd=2, pch=16, col=cols, legend=names(cols))
# dev.off()
# berryFunctions::openFile(file.path(clean_dir, "P1_palm_hours_year_lines_nearest1.png"))
# 
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# # 7) SEASON-YEAR TIMING (onset/offset via season-year framing)
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# season_start_month <- 8    # Aug 1 season start (adjustable)
# thr_7d             <- 24   # 7-day threshold (hours)
# quiet_days         <- 15   # length of quiet window
# quiet_max_hours    <- 6    # quiet window allowance
# 
# daily2 <- copy(daily_all)
# daily2[, `:=`(
#   season_year  = ifelse(month(date) >= season_start_month, year(date), year(date)-1L),
#   season_start = as.IDate(sprintf("%d-%02d-01",
#                                   ifelse(month(date) >= season_start_month, year(date), year(date)-1L),
#                                   season_start_month))
# )]
# 
# daily2[, `:=`(
#   season_doy   = as.integer(date - season_start) + 1L
# )]
# 
# daily2 <- daily2[season_year %in% years_clean]
# 
# setorder(daily2, scheme, village, date)
# daily2[, `:=`(
#   palm_7d = frollsum(palm_hours, 7, align = "right", na.rm = TRUE),
#   anth_7d = frollsum(anth_hours, 7, align = "right", na.rm = TRUE),
#   palm_15d = frollsum(palm_hours, 15, align = "right", na.rm = TRUE),
#   anth_15d = frollsum(anth_hours, 15, align = "right", na.rm = TRUE)
# ), by = .(scheme, village)]
# 
# get_onset <- function(doy, s7, qsum, thr7, qmax) {
#   idx <- which(s7 >= thr7 & qsum <= qmax)
#   if (length(idx)) doy[idx[1]] else NA_integer_
# }
# get_offset <- function(doy, s7, thr7) {
#   idx <- which(s7 >= thr7)
#   if (length(idx)) doy[idx[length(idx)]] else NA_integer_
# }
# center_of_mass_doy <- function(doy, w) {
#   w[!is.finite(w)] <- 0
#   if (sum(w) <= 0) return(NA_integer_)
#   theta <- 2*pi * (doy - 1) / max(doy, na.rm = TRUE)
#   x <- sum(w * cos(theta)) / sum(w)
#   y <- sum(w * sin(theta)) / sum(w)
#   ang <- atan2(y, x); if (ang < 0) ang <- ang + 2*pi
#   as.integer(round((ang / (2*pi)) * max(doy, na.rm = TRUE))) + 1L
# }
# 
# seasonal <- daily2[, {
#   on_p  <- get_onset(season_doy, palm_7d, palm_15d, thr_7d, quiet_max_hours)
#   off_p <- get_offset(season_doy, palm_7d, thr_7d)
#   on_a  <- get_onset(season_doy, anth_7d, anth_15d, thr_7d, quiet_max_hours)
#   off_a <- get_offset(season_doy, anth_7d, thr_7d)
#   .(palm_onset_doy = on_p, palm_offset_doy = off_p,
#     anth_onset_doy = on_a, anth_offset_doy = off_a,
#     palm_com_doy = center_of_mass_doy(season_doy, palm_hours),
#     anth_com_doy = center_of_mass_doy(season_doy, anth_hours),
#     palm_peak30_doy = if (all(is.na(frollsum(palm_hours, 30, align="right")))) NA_integer_
#     else season_doy[which.max(frollsum(palm_hours,30,align="right"))],
#     anth_peak30_doy = if (all(is.na(frollsum(anth_hours, 30, align="right")))) NA_integer_
#     else season_doy[which.max(frollsum(anth_hours,30,align="right"))])
# }, by = .(scheme, village, season_year)]
# 
# # Plots: peak30 & center-of-mass (nearest1)
# sea_near <- seasonal[scheme=="nearest1"]
# png(file.path(out_root, "P2_season_timing_peak30_and_center.png"), 1600, 900, res = 150)
# par(mfrow=c(1,2), mar=c(4.2,5,3,1.2), mgp=c(2.6,0.9,0), las=1, tcl=-0.25, cex.main=1.5, cex.lab=1.3, cex.axis=1.1)
# for (vil in c("Mandena","Sarahandrano")) {
#   s <- sea_near[village==vil]
#   plot(s$season_year, s$palm_peak30_doy, pch=16, col="gray20",
#        xlab="Season-year", ylab="DOY", ylim=c(1,365),
#        main=paste0("Phytophthora timing - ", vil))
#   points(s$season_year, s$palm_com_doy, pch=1, col="gray20")
#   abline(h=seq(0,360,60), col="gray90")
#   legend("topleft", bty="n", pch=c(16,1),
#          legend=c("Peak 30-day DOY","Center-of-mass DOY"))
# }
# dev.off()
# berryFunctions::openFile(file.path(out_root, "P2_season_timing_peak30_and_center.png"))
# 
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# # 8) WORKABILITY OVER TIME (nearest1)
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# yr_work <- yearly[scheme=="nearest1", .(village, year, work_day_pct, work_all_pct)]
# png(file.path(out_root, "P_workability_year_day_nearest1.png"), 1400, 900, res = 150)
# par(mar=c(4.2,5,3,1.2), mgp=c(2.6,0.9,0), las=1, tcl=-0.25, cex.main=1.5, cex.lab=1.3, cex.axis=1.1)
# yl <- range(pretty(yr_work$work_day_pct, 8), na.rm = TRUE)
# plot(NA, xlim = range(yr_work$year), ylim = yl, xaxs="i",
#      xlab="Year", ylab="Workability (%, 09-16)",
#      main="Workability over time (daytime, nearest1)")
# abline(h=pretty(yl), col="gray90")
# for (vil in unique(yr_work$village)) {
#   s <- yr_work[village==vil]
#   lines(s$year, s$work_day_pct, lwd=2, col=ifelse(vil=="Mandena","gray20","gray55"))
#   points(s$year, s$work_day_pct, pch=16, col=ifelse(vil=="Mandena","gray20","gray55"))
# }
# legend("topleft", bty="n", lwd=2, pch=16, col=c("gray20","gray55"),
#        legend=c("Mandena","Sarahandrano"))
# dev.off()
# berryFunctions::openFile(file.path(out_root, "P_workability_year_day_nearest1.png"))
# 
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# # 9) RISK-DAYS (day-level) - plain language outputs
# # ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
# riskday_min_hours   <- 4
# level_low_max       <- 1
# level_mod_max       <- 5
# sustained_7d_thresh <- 24
# 
# daily_near <- daily_all[scheme=="nearest1"]
# daily_near[, `:=`(
#   risk_day_palm = palm_hours >= riskday_min_hours,
#   level_palm = fifelse(palm_hours <= level_low_max, "Low",
#                        fifelse(palm_hours <= level_mod_max, "Moderate", "High"))
# )]
# 
# daily_near$month <- jj::lmonth(daily_near$date)
# # Monthly averages across years
# monthly_counts <- daily_near[, .(
#   risk_days = sum(risk_day_palm, na.rm = TRUE),
#   n_days    = .N
# ), by = .(village, year, month)]
# 
# monthly_avg <- monthly_counts[, .(
#   risk_days_mean = mean(risk_days, na.rm = TRUE),
#   pct_days_risky = 100 * mean(risk_days / n_days, na.rm = TRUE)
# ), by = .(village, month)][order(village, month)]
# 
# # Levels per month (avg)
# monthly_levels <- daily_near[, .(
#   Low      = sum(level_palm=="Low",      na.rm=TRUE),
#   Moderate = sum(level_palm=="Moderate", na.rm=TRUE),
#   High     = sum(level_palm=="High",     na.rm=TRUE)
# ), by = .(village, year, month)]
# monthly_levels_avg <- monthly_levels[, lapply(.SD, mean, na.rm=TRUE),
#                                      by = .(village, month),
#                                      .SDcols=c("Low","Moderate","High")]
# 
# # Longest streak per year
# longest_streak <- function(x) { if (!any(x)) 0L else { r <- rle(x); max(r$lengths[r$values]) } }
# streaks <- daily_near[, .(longest_run_days = longest_streak(risk_day_palm)),
#                       by = .(village, year)][order(village, year)]
# 
# # Rolling 7-day series (latest common year with good coverage)
# daily_near[, `:=`(year = year(date))]
# comp <- daily_near[, .(frac_ok = mean(is.finite(palm_hours))), by = .(village, year)]
# years_both <- Reduce(intersect, split(comp[frac_ok>=0.95]$year, comp$village))
# sel_year <- if (length(years_both)) max(years_both) else max(comp$year)
# sel <- daily_near[year==sel_year][order(village, date)]
# sel[, risk_7d := frollsum(palm_hours, 7, align="right", na.rm=TRUE), by = village]
# 
# # Save CSVs
# risk_out <- file.path(out_root, "riskdays_nearest1")
# dir.create(risk_out, showWarnings = FALSE, recursive = TRUE)
# fwrite(monthly_avg,        file.path(risk_out, "riskdays_monthly_counts.csv"))
# fwrite(monthly_levels_avg, file.path(risk_out, "riskdays_monthly_levels.csv"))
# fwrite(streaks,            file.path(risk_out, "riskdays_longest_streaks_by_year.csv"))
# fwrite(sel[, .(village, date, palm_hours, risk_7d)],
#        file.path(risk_out, "riskdays_7day_series_selectedyear.csv"))
# 
# # Plots (base R)
# png(file.path(risk_out, "P_riskdays_monthly_bars.png"), 1500, 950, res=150)
# par(mar=c(4.4,5.2,3.6,1.2), mgp=c(2.8,1,0), las=1, tcl=-0.25, cex.main=1.55, cex.lab=1.35, cex.axis=1.15)
# vils <- unique(monthly_avg$village)
# mat <- rbind(
#   sapply(1:12, function(m) monthly_avg[village==vils[1] & month==m, risk_days_mean]),
#   sapply(1:12, function(m) monthly_avg[village==vils[2] & month==m, risk_days_mean])
# )
# rownames(mat) <- vils
# yl <- range(pretty(mat, 8), na.rm = TRUE)
# mid <- barplot(mat, beside=TRUE, ylim=yl, col=c("gray30","gray70"),
#                border="gray30", names.arg=month.abb, cex.names=1.1,
#                main=sprintf("Risk days per month (mean, %d-%d)", min(years_clean), max(years_clean)),
#                ylab="Days per month (avg)")
# abline(h=pretty(yl), col="gray90"); box()
# legend("topleft", bty="n", fill=c("gray30","gray70"), border="gray30", legend=rownames(mat))
# dev.off()
# berryFunctions::openFile(file.path(risk_out, "P_riskdays_monthly_bars.png"))
# 
# 
# 
# 
# png(file.path(risk_out, "P_risklevels_monthly_stacked.png"), 1600, 950, res=150)
# par(mfrow=c(1,2), mar=c(4.4,5.2,3.6,1.2), mgp=c(2.8,1,0), las=1, tcl=-0.25, cex.main=1.55, cex.lab=1.35, cex.axis=1.15)
# cols_stack <- c(Low="gray88", Moderate="gray65", High="gray35")
# for (vil in vils) {
#   S <- t(as.matrix(monthly_levels_avg[village==vil, .(Low,Moderate,High)]))
#   colnames(S) <- month.abb[monthly_levels_avg[village==vil, month]]
#   yl <- range(pretty(colSums(S), 8), na.rm=TRUE)
#   barplot(S, col=cols_stack, border="gray30", ylim=yl,
#           main=paste0(vil, " - day types per month (avg)"), ylab="Days per month (avg)")
#   abline(h=pretty(yl), col="gray90"); box()
#   if (vil==vils[1]) legend("topleft", bty="n", fill=cols_stack, border="gray30", legend=names(cols_stack))
# }
# dev.off()
# berryFunctions::openFile(file.path(risk_out, "P_risklevels_monthly_stacked.png"))
# 
# 
# 
# 
# 
# png(file.path(risk_out, "P_7day_rolling_selectedyear.png"), 1500, 950, res=150)
# par(mar=c(4.4,5.2,3.6,1.2), mgp=c(2.8,1,0), las=1, tcl=-0.25, cex.main=1.55, cex.lab=1.35, cex.axis=1.15)
# xlim <- range(sel$date, na.rm=TRUE); yl <- range(pretty(sel$risk_7d, 8), na.rm=TRUE)
# plot(NA, xlim=xlim, ylim=yl, xaxs="i",
#      xlab=sprintf("Date (selected year: %d)", sel_year),
#      ylab="7-day total risk hours",
#      main=sprintf("Rolling 7-day totals - sustained risk = %dh (dashed)", sustained_7d_thresh))
# abline(h=pretty(yl), col="gray90"); abline(h=sustained_7d_thresh, col="gray30", lty=2, lwd=1.5)
# for (vil in vils) {
#   s <- sel[village==vil]
#   lines(s$date, s$risk_7d, lwd=2, col=ifelse(vil=="Mandena","gray20","gray55"))
# }
# legend("topleft", bty="n", lwd=2, col=c("gray20","gray55"), legend=vils)
# dev.off()
# berryFunctions::openFile(file.path(risk_out, "P_7day_rolling_selectedyear.png"))
# 
# 
# 
# 
# 
# cat("\n??? Pipeline complete.\nOutputs:\n",
#     "- Streamed hourly/daily parquet: ", stream_dir, "\n",
#     "- Clean (2000-2022): ", clean_dir, "\n",
#     "- Season timing plot: ", file.path(out_root, "P2_season_timing_peak30_and_center.png"), "\n",
#     "- Workability plot: ", file.path(out_root, "P_workability_year_day_nearest1.png"), "\n",
#     "- Risk-day CSVs & PNGs: ", risk_out, "\n\n", sep="")
